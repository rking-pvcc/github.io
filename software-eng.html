<!DOCTYPE html>
<!-- NAME Robert King
    PROG PURPOSE: Chapter 7: Software Engineering
-->
<html lang="en">
<head>
    <title>Chapter 6 Terminology Table</title>
</head>
<body style="color: #f9db60;; background-color: #36727f; font-family: calibri;"></body>
<h1>Software Engineering Terminology</h1>

<table border="1" style="text-align:center;" width="560" >
        <tr style="font-weight:bold; font-size: 120%;">
            <td>Terms</td>
            <td>Defintions</td>
        </tr>
        <tr>
            <td>Software Engineering</td>
            <td>Software Engineering is the branch of computer science that seeks principles to guide the development of large, complex software systems.</td>
        </tr>
        <tr>
            <td>Integrated Development Enviroment (IDE)</td>
            <td>Integrated Development Enviroments combine tools for developing software (editors, compilers, debugging tools, and so on) into a single, integrated package. These not only provide the programming tools necessary to write and debug the software but also provide simulators that, by means of graphical displays, allow a programmer to see how the software being developed would actually perform on a phone.</td>
        </tr>
        <tr>
            <td>Association for Computing Machinery (ACM)</td>
            <td>The Association for Computing Machinery was founded in 1947 as an international scientific and educational organization dedicated to advancing the arts, sciences, and applications of information technology.</td>
        </tr>
        <tr>
            <td>Purpose of ACM</td>
            <td>The purpose of ACM is to advance the art, science, engineering, and application of computing, serving both professional and public interests by fostering the open exchange of information and by promoting the highest professional and ethical standards.</td>
        </tr>
        <tr>
            <td>Benefits of ACM membership</td>
            <td>Becoming a member of ACM provides the tools and resources to help shape the future of computing by advancing your career and enriching your knowledge with life-long learning resources.</td>
        </tr>
        <tr>
            <td>Student ACM membership</td>
            <td>Student ACM membership provide unique opportunities for networking, mentoring, bonding over common intesrests and provide support both within the student community and to local communities outside the institution.</td>
        </tr>
        <tr>
            <td>Institute of Electrical and Electronics Engineers (IEEE)</td>
            <td>Institute of Electrical and Electronics Engineers (IEEE) is the world's largest technical professional society.</td>
        </tr>
        <tr>
            <td>Purpose of IEEE</td>
            <td>The purpose of IEEE is to advance innovation and technological excellence for the benefit of humanity and is designed to serve professionals involved in all aspects of the electrical, electronic, and computing fields and related areas of science and technology that underlie modern civilization.</td>
        </tr>
        <tr>
            <td>Benefits of IEEE membership</td>
            <td>The benefits of an IEEE membership is network with other technology professionals, establish a professional profile highlighting your accomplishments, join and participate in discussions on various technical interests, create a group to share and collaborate on projects, and discover IEEE events and activities throughout the world.</td>
        </tr>
        <tr>
            <td>Student IEEE membership</td>
            <td>IEEE has the needs for you to remain technically current through competitions and award-winning publications, and student members have access to numerous continuing education opportunities at discounted rates</td>
        </tr>
        <tr>
            <td>Software Life Cycle: Development Phase</td>
            <td>Once the software is developed, it enters a cycle of being used and maintained - a cycle that continues for the rest of the software's life.</td>
        </tr>
        <tr>
            <td>Requirements Analysis</td>
            <td>The software life cycle begins with requirements analysis - the goal of which is to specify what services the proposed system will provide, to identify any conditions (time constraints, security, and so on) on those services, and to define how the outside world will interact with the system.</td>
        </tr>
        <tr>
            <td>Design</td>
            <td>The design phase involves creating a plan for the construction of the proposed system. In a sense, requirements analysis is about identifying the problem to be solved, while design is about developing a solution to the problem.</td>
        </tr>
        <tr>
            <td>Implementation</td>
            <td>Implementation involves the actual writing of programs, creating of data files, and development of databases. It is at the implementation stage that we see the distinction between the tasks of a software analyst (sometimes referred to as a system analyst) and a programmer.</td>
        </tr>
        <tr>
            <td>Testing</td>
            <td>In the traditional development phase of the past, testing was essentially equated with the process of debugging programs and confirming that the final software product was compatible with the software requirements specification. Today, however, this vision of testing is considered too narrows. Programs are not the only artifacts that are tested during the software development process. Indeed, the result of each intermediate step in the entire development process should be "tested" for accuracy.</td>
        </tr>
        <tr>
            <td>Modular Implementation</td>
            <td>Modular Implementation is separating a program's functions into independent pieces of building blocks, each containing all the parts needed to execute a single aspect of the functionality.</td>
        </tr>
        <tr>
            <td>Unifed Modeling Language (UML)</td>
            <td>Dataflow diagrams and data dictionaries were tools in the software engineering arsenal well before the emergence of the object-orientated paradigm and have continued to find useful roles even though the imperative paradigm, for which they were originally developed, has faded in popularity. We turn now to the more modern collection of tools known as Unified Modeling Language (UML) that has been developed with the object-oriented paradigm in mind.</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Use cases are the interactions within a use case diagram from the users of the system (called actors).</td>
        </tr>
        <tr>
            <td>Use Case Diagram</td>
            <td>The first tool that we consider within this collection of UML is useful regardless of the underlying paradigm because it attempts merely to capture the image of the proposed system from the user's point of view. This tool is the use case diagram which depicits the proposed system as a large rectangle in which interactions (called use cases) between the system and its users are represented as ovals and users of the system (called actors) are represented as stick figures.</td>
        </tr>
        <tr>
            <td>Data Relationship: One-to-One</td>
            <td>A one-to-one relationship is exemplified by the association between patients and occupied privates rooms in that each patient is associated with only one room and each room is associated with only one patient.</td>
        </tr>
        <tr>
            <td>Data Relationship: One-to-Many</td>
            <td>A one-to-many relationship is exemplified by the association between physicians and patients in that one phyisician is associated with many patients and each patient is associated with one (primary) physician.</td>
        </tr>
        <tr>
            <td>Data Relationship: Many-to-Many</td>
            <td>A Many-to-Many relationship would occur if we included consulting physicians in the physician-patient relationship.</td>
        </tr>
        <tr>
            <td>Design Pattern</td>
            <td>An increasingly powerful tool for software engineers is the growing collection of design patterns. A design pattent is a predeveloped model for solving a recurring problem in software design.</td>
        </tr>
        <tr>
            <td>Software Quality Assurance (SQA)</td>
            <td>Many major software contractors now require that the organizations they hire to develop software meet such standards. As a result, software development companies are establishing software quality assurance (SQA) groups, which are charged with overseeing and enforcing the quality control systems adopted by the organization.</td>
        </tr>
        <tr>
            <td>Software Testing: Glass Box Testing</td>
            <td>Glass Box Testing is when the software tester is aware of the interior structure of the software and uses this knowledge when designing the software test.</td>
        </tr>
        <tr>
            <td>Software Testing: Black Box Testing</td>
            <td>Black Box Testing refers to tests that do not rely on knowledge of the software's interior composition.</td>
        </tr>
        <tr>
            <td>Software Testing: Beta Testing</td>
            <td>Another methodology that falls within the black-box category is beta testing in which a preliminary version of the software is given to a segment of the intended audience with the goal of learning how the software performs in real-life situations before the final version of the product is solidified and released to the market.</td>
        </tr>
        <tr>
            <td>Software Testing: Alpha Testing</td>
            <td>Similar testing performed at the developer's site is called alpha testing.</td>
        </tr>
        <tr>
            <td>Documentation: User Documentation</td>
            <td>The purpose of user documentation is to explain the features of the software and describe how to use them and is intended to be read by the user of the software and is therefore expressed in the terminology of the application.</td>
        </tr>
        <tr>
            <td>Documentation: System Documentation</td>
            <td>The purpose of system documentation is to describe the software's internal composition so that the software can be maintained later in its life cycle. Another component of system documentation is a record of the design documents including the software requirements specification and records showing how these specifications were obtained during design.</td>
        </tr>
        <tr>
            <td>Documentation: Technical Documentation</td>
            <td>The purpose of technical documentation is to describe how a software system should be installed and serviced (such as adjusting operating parameters, installing updates, and reporting problems back to the software's developer).</td>
        </tr>
        <tr>
            <td>Intellectual Property Law</td>
            <td>Legal efforts to provide such ownership, that software developers want over the software they produce, fall under the category of intellectual property law, much of which is based on the well-established principles of copyright and patent law.</td>
        </tr>
        <tr>
            <td>Software License</td>
            <td>The rights of the developer are formally expressed in legal terms in a software license which is a legal agreement between the owner and user of a software product that grants the user certain permissions to use the product without transferring ownership rights to the intellectual property.</td>
        </tr>
        <tr>
            <td>Software Disclaimer</td>
            <td>Software developers often include disclaimers in the software licenses that state the limitations of their liability to protect themselves against liability.</td>
        </tr>
        <tr>
            <td>Best Defenses Against Software Liability Claims</td>
            <td>One of the best defenses against software liability claims is to apply sound software engineering principles during the software's development, to use a level of care compatible with the software's application, and to produce and maintain records that validate these endeavors.</td>
        </tr>